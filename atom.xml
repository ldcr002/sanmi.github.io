<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanmi&#39;s blog</title>
  
  <subtitle>天下武功，无坚不破，唯快不破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sanmi.site/"/>
  <updated>2019-10-12T08:56:47.761Z</updated>
  <id>http://blog.sanmi.site/</id>
  
  <author>
    <name>SanmiYoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>requests库中content和text调用的区别</title>
    <link href="http://blog.sanmi.site/2019/10/12/requests%E5%BA%93%E4%B8%ADcontent%E5%92%8Ctext%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.sanmi.site/2019/10/12/requests库中content和text调用的区别/</id>
    <published>2019-10-12T08:50:03.000Z</published>
    <updated>2019-10-12T08:56:47.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requests库中content和text调用的区别"><a href="#requests库中content和text调用的区别" class="headerlink" title="requests库中content和text调用的区别"></a>requests库中content和text调用的区别</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近，在使用python的requests库抓取一些网站基本信息的时候。使用r.text提取信息。发现经常会有乱码。即使原网站的原始编码就是utf-8. 后来发现，改成r.content就没问题。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>二者的区别在于content返回的是byte型数据，而text返回的是Unicode数据，也就是说text对原始数据进行的特殊的编码，而这个编码方式是基于对原始数据的猜测(响应头)，</p><p>所以，如果网站的返回头如果没有制定编码，则r.text获取到的内容则可能编码出现错误。</p><p>如：<code>Content-Type: text/html; charset=utf-8</code></p><p>所以，一般情况下建议用r.content。然后自己进行重新编码。</p><p>如果非要用text则可使用<code>r.encoding = &#39;ISO-8859-1&#39;</code>指定编码格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="python" scheme="http://blog.sanmi.site/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>wget备忘录</title>
    <link href="http://blog.sanmi.site/2019/06/06/wget%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://blog.sanmi.site/2019/06/06/wget备忘录/</id>
    <published>2019-06-06T07:27:42.000Z</published>
    <updated>2019-06-06T07:32:34.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用wget克隆网站"><a href="#使用wget克隆网站" class="headerlink" title="使用wget克隆网站"></a>使用wget克隆网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -k -p -nH -N http://xxxweb.com</span><br></pre></td></tr></table></figure><p><strong>各参数说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-k     把已下载文件中的所有链接都转换为本地引用，不再依赖原始或在线内容</span><br><span class="line">-p     下载所有必要文件，确保离线可用，包括图片和样式表</span><br><span class="line">-nH    禁止把文件下载到以主机名为前缀的文件夹中</span><br><span class="line">-N     启用文件的时间戳，以匹配来源的时间戳</span><br><span class="line"></span><br><span class="line">下面两项可选:</span><br><span class="line">-r     递归下载</span><br><span class="line">-l     指定最大的递归深度，0为无限。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.sanmi.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker for Mac与宿主机通信</title>
    <link href="http://blog.sanmi.site/2019/06/06/Docker-for-Mac%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.sanmi.site/2019/06/06/Docker-for-Mac与宿主机通信/</id>
    <published>2019-06-06T01:42:12.000Z</published>
    <updated>2019-06-06T02:20:02.579Z</updated>
    
    <content type="html"><![CDATA[<p>因为Docker for Mac的实现与Docker for Linux的实现有些不一样，所以在Mac上，当容器需要与宿主机进行通信的时候，发现直接访问宿主机的IP（ 172.17.0.1）是访问不通的。Mac的宿主机上，也没有docker0这个虚拟网卡。<br>当尝试访问宿主机的一个端口时，会提示Connection refused.</p><p>在container中应当使用一个特殊的DNS来访问宿主机<code>docker.for.mac.host.internal</code></p><p>参考链接：(<a href="https://imhanjm.com/2018/12/16/macos%20docker%20container%E8%BF%9E%E6%8E%A5%E5%AE%BF%E4%B8%BB%E6%9C%BA172.17.0.1%E7%9A%84%E5%8A%9E%E6%B3%95/" target="_blank" rel="noopener">Macos Docker container连接宿主机172.17.0.1的办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.sanmi.site/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>me</title>
    <link href="http://blog.sanmi.site/2019/05/10/me/"/>
    <id>http://blog.sanmi.site/2019/05/10/me/</id>
    <published>2019-05-10T05:18:24.000Z</published>
    <updated>2019-05-10T05:18:24.438Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
