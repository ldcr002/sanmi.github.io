<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanmi&#39;s blog</title>
  
  <subtitle>天下武功，无坚不破，唯快不破</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sanmi.site/"/>
  <updated>2020-03-28T09:28:42.530Z</updated>
  <id>http://blog.sanmi.site/</id>
  
  <author>
    <name>SanmiYoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS系列(1)——XSS基础知识</title>
    <link href="http://blog.sanmi.site/2020/03/28/XSS%E7%B3%BB%E5%88%97-1-%E4%B9%8BXSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://blog.sanmi.site/2020/03/28/XSS系列-1-之XSS基础知识/</id>
    <published>2020-03-28T06:43:43.000Z</published>
    <updated>2020-03-28T09:28:42.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS系列-1-——XSS基础知识"><a href="#XSS系列-1-——XSS基础知识" class="headerlink" title="XSS系列(1)——XSS基础知识"></a>XSS系列(1)——XSS基础知识</h1><p>俗话说：「万丈高楼平地起」「不积跬步无以至千里」。<br>学习任何专业，基础知识非常的重要。基础知识是否扎实，决定了你能走多远。</p><p>目前网络上关于XSS的知识、介绍非常的多，成系统、系列的介绍却不多。本文争取集各家之所长，由浅及深的介绍XSS的相关知识。本文是XSS系列第一篇，先来介绍XSS相关的基础知识。因小弟才疏学浅，不足之处还望各位大佬多多指教。</p><p>本文参考了很多大佬的分享原作，在此表示感谢。我只是一个知识的搬运工。</p><h2 id="0x01-浏览器编码"><a href="#0x01-浏览器编码" class="headerlink" title="0x01 浏览器编码"></a>0x01 浏览器编码</h2><p>提到XSS，便不得不讲浏览器编码。浏览器编码虽不复杂，却也有许多细节之处常常被人忽略，而对于细节的掌握和理解是否到位，决定了有时候能否成功的编写一个XSS poc。</p><p>下面简单介绍下各类的编码类型。</p><h3 id="1-编码类型"><a href="#1-编码类型" class="headerlink" title="1. 编码类型"></a>1. 编码类型</h3><p>浏览器在解析HTML时，是按照一定的格式和编码来解析的，为了不扰乱HTML结构，有HTML编码（比如：<code>&lt;对应&amp;lt;</code>）;为了不扰乱JS的语法，有JS编码（比如：<code>&#39;对应\&#39;</code>），为了正常解析URL，有URL编码（比如：&amp;对应%26）。总结起来也就三类，但是有不同的编码形式。</p><p>在呈现HTML页面时，针对某些特殊字符如<code>&lt;</code>或<code>&gt;</code>直接使用，浏览器会误以为它们标签的开始或结束，若想正确的在HTML页面呈现特殊字符就需要用到其对应的字符实体。</p><h4 id="1-1-HTML编码"><a href="#1-1-HTML编码" class="headerlink" title="1.1 HTML编码"></a>1.1 HTML编码</h4><p>HTML编码形式最常见的有三种：<strong>别名形式、16进制形式、10进制形式</strong>，比如：<code>&lt;&gt;&quot;&#39;</code>采用这三种方式编码后分别如下：</p><ul><li>字符编码（别名形式）：<code>&amp;lt;&amp;gt;&amp;quot;&amp;apos;</code></li><li>16进制形式：<code>&amp;#x3c;&amp;#x3e;&amp;#x22;&amp;#x27;</code></li><li>10进制形式: <code>&amp;#60;&amp;#62;&amp;#34;&amp;#39;</code></li></ul><p><strong>HTML编码的这几种方式可以混合出现，浏览器都可以正常解析。</strong><br><strong>上述三种形式的分号均可以省略。</strong></p><h4 id="1-2-JS编码"><a href="#1-2-JS编码" class="headerlink" title="1.2 JS编码"></a>1.2 JS编码</h4><p>JS编码形式最常见的有四种：斜杠转义形式、16进制形式、Unicode编码形式。<code>&lt;&gt;&quot;&#39;</code>采用这几种方式编码后分别如下：</p><p>斜杠转义形式：<code>\&lt;\&gt;\&quot;\&#39;</code><br>16进制形式：<code>\x3c\x3e\x22\x27</code><br>Unicode编码形式：<code>\u003c\u003e\u0022\u0027</code></p><p><strong>注意：</strong></p><ul><li>在Unicode编码形式中，中间的字符可以是1-7个字符。如<code>\u000003c</code>。但是笔者在用最新版的Chrome浏览器中测试的时候，只有四个字符可以被正确的识别。各种缘由，暂不清楚。</li><li>这几种方式也可以混合出现。</li><li>一般的斜杠转义形式不对字母、数字进行转义，因为可能出现混乱的情况，比如：\x\3\c并不会按想象中那样解析成x3c，而是会报语法错误。</li></ul><h4 id="1-3-URL编码"><a href="#1-3-URL编码" class="headerlink" title="1.3 URL编码"></a>1.3 URL编码</h4><p>URL编码估计大家都非常熟悉，编码都采用%XX的形式，比如同样的<code>&lt;&gt;&quot;&#39;</code>经URL编码后得到%3C%3E%22%27。</p><p>需要注意的是，URL编码可以细分为encodeURI,encodeURIComponent两种编码形式，下面将简单说明一下两周编码形式的区别。</p><p><strong>encodeURI</strong></p><p>encodeURI 是用来处理整个 URI 的，它应该接受 URI 的 protocol, host, port以及URL中的功能字符<code>&amp;?/=</code> 等部分，只对 path 和 query 进行编码。</p><p>如果 POST 请求的 Request Header 中 Content-Type 为「application/x-www-form-urlencoded」， 那么 Request Payload 里面的数据一般就是使用 encodeURI(Component) 编码的。</p><p><strong>encodeURIComponent</strong></p><p>encodeURIComponent 对所有的字符均编码。</p><p><strong>举例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="string">'https://www.baidu.com/ a b c'</span>)</span><br><span class="line"><span class="string">"https://www.baidu.com/%20a%20b%20c"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">'https://www.baidu.com/ a b c'</span>)</span><br><span class="line"><span class="string">"https%3A%2F%2Fwww.baidu.com%2F%20a%20b%20c"</span></span><br></pre></td></tr></table></figure><p>其实除了以上两种URL编码外，还有escape编码，但因为escape已经从 Web 标准中删除，所以此处不做介绍。</p><h3 id="2-编码位置"><a href="#2-编码位置" class="headerlink" title="2. 编码位置"></a>2. 编码位置</h3><p>HTML页面中我们可以按照指定的编码格式去编码，但是，必须要在合适的位置用合适的编码，以及符合浏览器的解码规则和顺序，否则浏览器也无法识别。</p><h4 id="2-1-HTML编码适用位置"><a href="#2-1-HTML编码适用位置" class="headerlink" title="2.1 HTML编码适用位置"></a>2.1 HTML编码适用位置</h4><p>HTML编码适用于属性值、标签内的内容，看如下示例：</p><p><img src="/images/image-20191105184712054.png" alt="image-20191105184712054"></p><p>浏览器解析后如下图：</p><p><img src="/images/image-20191105184724878.png" alt="image-20191105184724878"></p><p>可以看到：</p><ol><li>标签内使用html编码，被解析出来了，并且不影响DOM结构。</li><li>属性值使用html编码，被解析出来了，并且在url、js事件、css中也是如此。</li><li>属性名使用html编码，没有被解析出来</li></ol><p>但是，在<code>&lt;script&gt;</code>标签内的js内容以及<code>&lt;style&gt;</code>中的css内容，浏览器是不会使用html编码解码的：</p><p><img src="/images/image-20191105184807888.png" alt="image-20191105184807888"></p><h4 id="2-2-JS编码适用位置"><a href="#2-2-JS编码适用位置" class="headerlink" title="2.2 JS编码适用位置"></a>2.2 JS编码适用位置</h4><p>JS编码则只适用于JS代码中，包括<code>&lt;script&gt;</code>内和JS事件中：</p><p><img src="/images/image-20191105184828120.png" alt="image-20191105184828120"></p><p>对于JavaScript，转义编码应当只出现在标示符部分，不能用于对语法有真正影响的符号，也就是括号，或者是引号。所以，对<code>(&#39;&#39;)</code>等进行js编码是失败的。</p><p><strong>示例代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="string">'dafaf'</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>可以对dafaf施行16进制编码Unicode编码形式以及斜杠转义形式<br>只可以对alert施行Unicode编码<br>不能对<code>(&#39;&#39;)</code>编码</p><p>我们来分析一下JavaScript解析的一个细节，Javascript解析器工作的时候将\u0061\u006c\u0065\u0072\u0074进行js解码后为“alert”，而“alert”是一个有效的标识符名称，它是能被正常解析的。<strong>像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称</strong>，例如：<code>&lt;script&gt;alert(&#39;LDkR\u0027)&lt;/script&gt;</code>对控制字符单引号进行js编码，解析时\u0027被解码成文本单引号，无法闭合因此不能成功执行。</p><h4 id="2-3-URL编码适用位置"><a href="#2-3-URL编码适用位置" class="headerlink" title="2.3 URL编码适用位置"></a>2.3 URL编码适用位置</h4><p>URL编码则只适用于为URL的属性值，且只能对URL中的参数进行URL编码。比如：<code>&lt;a&gt;</code>标签的href属性、<code>&lt;iframe&gt;</code>的src属性等。</p><h3 id="3-浏览器解析顺序"><a href="#3-浏览器解析顺序" class="headerlink" title="3. 浏览器解析顺序"></a>3. 浏览器解析顺序</h3><p>既然各个编码有适合自己的位置，并且这种位置必定会重合，所以，浏览器解码必定有一定的顺序。</p><p>首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。</p><p>浏览器无论什么情况都会遵守一个这样的解码规则：</p><blockquote><p>1、 HTML 解析器对 HTML 文档进行解析，完成 HTML 解码并且创建 DOM 树</p><p>2、 JavaScript 或者 CSS 解析器对内联脚本进行解析，完成 JS、CSS 解码</p><p>3、 URL 解码会根据 URL 所在的顺序不同而在 JS 解码前或者解码后</p></blockquote><p>下面，讲距离几个具体的例子，对解码顺序做一些说明，以方便理解和记忆。</p><h4 id="3-1-解码举例1"><a href="#3-1-解码举例1" class="headerlink" title="3.1 解码举例1"></a>3.1 解码举例1</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">"&amp;#97;lert(1)"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&amp;#35; on\u0065rror=&amp;#97;lert&amp;#40;1)&gt;"</span>;  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个正常的容易理解的过程是这一行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">"&amp;#97;lert(1)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 解析到标签，建立DOM 树，然后对节点内容进行实体解码，&amp;#97； 就变成a, 随后在js 解析阶段，正常的触发了弹窗，先后顺序OK。</p><p>但对于下面这段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&amp;#35; on\u0065rror=&amp;#97;lert&amp;#40;1)&gt;"</span>;  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>使用了DOM 操作，修改前边标签中的内容，添加了一个img 内容，因为进入了script 进入了JavaScript的特殊解析模式，所以此处HTML 不得干扰，首先JavaScript解析器，会先对其中编码的内容解码，于是onerror 就还原回来了，于是正常的执行了JS 语句，在HTML 文档中，将hello 变成了img。img标签内容变成了：</p><p><code>&lt;img src=&amp;#35; onerror=&amp;#97;lert&amp;#40;1)&gt;</code></p></li><li><p>该标签传回给HTML，HTML 建立DOM节点，HTML解码节点内容：<code>&lt;img src=x onerror=alert(1)&gt;</code></p></li><li><p>onerror 又会执行其中的JS 脚本，弹出窗口。</p></li></ol><p>其实，这里也不难理解，因为HTML 是从上到下解析，遇到&lt; script&gt; 于是进入了特殊的解析模式，使用JS 解析器，做了一个DOM 操作，该DOM 操作修改了前边的DOM 树，该块内容，需要使用HTML 解析重塑DOM 树，那么节点内容中的实体编码就会被解码，然后onerror 中触发脚本，JS 又会对内容进行一次解析。</p><p>总结说来，实际上，DOM 操作实际上是js强势介入 HTML 和CSS 的结果，使用DOM 操作，对DOM Tree 造成了改变，会调用到HTML 解析器重新对其解析，于是流程又会返回到最开始说的那个解析流程里去。</p><h4 id="3-2-解码举例2"><a href="#3-2-解码举例2" class="headerlink" title="3.2 解码举例2"></a>3.2 解码举例2</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>针对上述a标签我们分析一下该环境中浏览器的解析顺序，首先HTML解析器开始工作，并对href中的字符做HTML解码，接下来URL解析器对href值进行解码，正常情况下URL值为一个正常的URL链接，如：“<a href="https://www.baidu.com“，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为JavaScript，因此该环境中最后一步JavaScript解析器还会进行解码操作，最后解析的脚本被执行。" target="_blank" rel="noopener">https://www.baidu.com“，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为JavaScript，因此该环境中最后一步JavaScript解析器还会进行解码操作，最后解析的脚本被执行。</a></p><p><strong>整个解析顺序为3个环节：HTML解码 –&gt; URL解码 –&gt; JS解码</strong></p><p><strong>变形1：</strong>URL编码 <code>javascript:alert(1)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL编码“javascript:alert(1)”=“%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29”</span><br><span class="line"></span><br><span class="line">编码后：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，该脚本并不会被正常的执行。这里就有一个URL解析过程中的一个细节了，<strong>不能对协议类型进行任何的编码操作</strong>，否则URL解析器会认为它无类型，就导致被编码的“javascript”没有解码，所以不会被URL解析器识别。</p><p><strong>变形2：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTML编码"javascript"="&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;"</span><br><span class="line">URL编码"alert(2)"=” %61%6C%65%72%74%28%32%29”</span><br><span class="line"></span><br><span class="line">编码后:</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:%61%6C%65%72%74%28%32%29"</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>HTML解析器工作时，href里的HTML实体会被解码。变成<code>&lt;a href=&quot;javascript:%61%6C%65%72%74%28%32%29&quot;</code></p></li><li><p>接下来URL解析器工作解析href属性里的链接时，”javascript”协议在第一步被HTML解码了，这样URL解析器是可以识别的，然后继续解析后面的”%61%6C%65%72%74%28%32%29”，变成<code>&lt;a href=&quot;javascript:a lert(1)&quot;&gt;</code></p></li><li><p>最后JavaScript解析器完成解析操作，脚本执行。</p></li></ol><p><strong>变形3：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(3)"</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span>做JS编码&gt;URL编码&gt;HTML编码共3层。</span><br><span class="line"></span><br><span class="line">JS编码：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(3)"</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">URL编码：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)"</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">HTML编码：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#51;&amp;#41;"</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照上面的逻辑分析，是可以被正常解析之行的。</p><h4 id="3-3-解码举例3"><a href="#3-3-解码举例3" class="headerlink" title="3.3 解码举例3"></a>3.3 解码举例3</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"window.open('UserInput')"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>首先由 HTML 解析器对UserInput 部分进行字符实体解码；</li><li>接着由 JavaScript 解析器会再对 onclick 部分的 JS 进行解析并执行 JS；</li><li>执行 JS 后window.open(‘UserInput’)函数的参数会传入 URL，所以再由 URL 解析器对 UserInput 部分进行解码。</li></ol><p><strong>解析顺序为：HTML 解析-&gt;JavaScript解析-&gt;URL 解析。</strong></p><h4 id="3-4解码举例4"><a href="#3-4解码举例4" class="headerlink" title="3.4解码举例4"></a>3.4解码举例4</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:window.open('UserInput')"</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>首先还是由 HTML 解析器对 UserInput 部分进行字符实体解码；</li><li>接着由 URL 解析器解析 href 的属性值；</li><li>然后由于Scheme为javascript，所以由 JavaScript 解析；</li><li>解析执行 JS 后window.open(‘UserInput’)函数传入 URL，所以再由 URL 解析器解析。</li></ol><p><strong>解析顺序为：HTML 解析-&gt;URL解析-&gt;JavaScript 解析-&gt;URL 解析。</strong></p><h4 id="3-5-解码举例5"><a href="#3-5-解码举例5" class="headerlink" title="3.5 解码举例5"></a>3.5 解码举例5</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>首先 HTML 解析器进行解析，解析到href 属性的值时，状态机进入属性值状态（Attribute Value State），该状态会解码字符实体；</p></li><li><p>接着由 URL 解析器进行解析并解码；</p></li><li><p>再接着由于 Scheme 为javascript，因此由 JavaScript 解析器解析并解码，加上编码部分是函 数名，属于标识符，因此可以正常解码解释；</p></li></ol><p>经过三轮解析解码后得到结果：<a href="javascript:alert(15)" target="_blank" rel="noopener"></a></p><h3 id="4-哪些地方可以触发JS解析器"><a href="#4-哪些地方可以触发JS解析器" class="headerlink" title="4.哪些地方可以触发JS解析器"></a>4.哪些地方可以触发JS解析器</h3><ol><li>直接嵌入&lt; script&gt; 代码块。</li><li>通过&lt; script sr=… &gt; 加载代码。</li><li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li><li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li><li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li><li>定时器，Timer(setTimeout, setInterval)</li><li>eval(…) 调用。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://security.yirendai.com/news/share/26" target="_blank" rel="noopener">https://security.yirendai.com/news/share/26</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="XSS" scheme="http://blog.sanmi.site/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>通过adb修改手机的代理设置</title>
    <link href="http://blog.sanmi.site/2019/11/21/%E9%80%9A%E8%BF%87adb%E4%BF%AE%E6%94%B9%E6%89%8B%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
    <id>http://blog.sanmi.site/2019/11/21/通过adb修改手机的代理设置/</id>
    <published>2019-11-21T02:16:03.000Z</published>
    <updated>2019-11-21T02:40:19.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过adb修改手机的代理设置"><a href="#通过adb修改手机的代理设置" class="headerlink" title="通过adb修改手机的代理设置"></a>通过adb修改手机的代理设置</h1><h2 id="0x00-前置"><a href="#0x00-前置" class="headerlink" title="0x00 前置"></a>0x00 前置</h2><p>在使用MUMU模拟器的时候，经常重启模拟器卡在99%的位置起不来，按照官方指引排错之后依然无法解决问题。后来联系MUMU的同事，经过确认，如果模拟器设置了系统代理没有关闭，重启后就会卡在99%。</p><p>但是，卡在99%的时候，是可以通过adb进入系统的。此时，可以通过adb修改手机的代理设置，然后重启就OK了。</p><h2 id="0x01-如何修改"><a href="#0x01-如何修改" class="headerlink" title="0x01 如何修改"></a>0x01 如何修改</h2><p><strong>方法一</strong></p><p>网上百度到的方法大都是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置代理：</span></span><br><span class="line">adb shell settings put global http_proxy 代理IP地址:端口号</span><br><span class="line">如：</span><br><span class="line">adb shell settings put global http_proxy 127.0.0.1:8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除代理：</span></span><br><span class="line">adb shell settings delete global http_proxy</span><br><span class="line">adb shell settings delete global global_http_proxy_host</span><br><span class="line">adb shell settings delete global global_http_proxy_port</span><br></pre></td></tr></table></figure><p>但是，这个方法对对MUMU不起作用，都是提示没有删除。</p><p><img src="/images/image-20191121102144577.png" alt="image-20191121102144577"></p><p><strong>方法二</strong></p><p>经过研究，发现了方法二，确认有效。 </p><ol><li><p>通过adb进入shell</p></li><li><p>确认是root权限</p></li><li><p>编辑<code>/data/misc/wifi/ipconfig.txt</code>删除掉代理相关的配置</p><p>删除之后，ipconfig.txt文件中的内容是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^@^@^@^B^@^LipAssignment^@^DDHCP^@^MproxySettings^@^FSTATIC^@   ^@^MexclusionList^@^@^@^Bid�D�^@^Ceos</span><br></pre></td></tr></table></figure></li><li><p>reboot</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Android" scheme="http://blog.sanmi.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>requests库中content和text调用的区别</title>
    <link href="http://blog.sanmi.site/2019/10/12/requests%E5%BA%93%E4%B8%ADcontent%E5%92%8Ctext%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.sanmi.site/2019/10/12/requests库中content和text调用的区别/</id>
    <published>2019-10-12T08:50:03.000Z</published>
    <updated>2019-10-12T08:56:47.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requests库中content和text调用的区别"><a href="#requests库中content和text调用的区别" class="headerlink" title="requests库中content和text调用的区别"></a>requests库中content和text调用的区别</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近，在使用python的requests库抓取一些网站基本信息的时候。使用r.text提取信息。发现经常会有乱码。即使原网站的原始编码就是utf-8. 后来发现，改成r.content就没问题。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>二者的区别在于content返回的是byte型数据，而text返回的是Unicode数据，也就是说text对原始数据进行的特殊的编码，而这个编码方式是基于对原始数据的猜测(响应头)，</p><p>所以，如果网站的返回头如果没有制定编码，则r.text获取到的内容则可能编码出现错误。</p><p>如：<code>Content-Type: text/html; charset=utf-8</code></p><p>所以，一般情况下建议用r.content。然后自己进行重新编码。</p><p>如果非要用text则可使用<code>r.encoding = &#39;ISO-8859-1&#39;</code>指定编码格式。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="python" scheme="http://blog.sanmi.site/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>wget备忘录</title>
    <link href="http://blog.sanmi.site/2019/06/06/wget%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://blog.sanmi.site/2019/06/06/wget备忘录/</id>
    <published>2019-06-06T07:27:42.000Z</published>
    <updated>2019-06-06T07:32:34.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用wget克隆网站"><a href="#使用wget克隆网站" class="headerlink" title="使用wget克隆网站"></a>使用wget克隆网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -k -p -nH -N http://xxxweb.com</span><br></pre></td></tr></table></figure><p><strong>各参数说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-k     把已下载文件中的所有链接都转换为本地引用，不再依赖原始或在线内容</span><br><span class="line">-p     下载所有必要文件，确保离线可用，包括图片和样式表</span><br><span class="line">-nH    禁止把文件下载到以主机名为前缀的文件夹中</span><br><span class="line">-N     启用文件的时间戳，以匹配来源的时间戳</span><br><span class="line"></span><br><span class="line">下面两项可选:</span><br><span class="line">-r     递归下载</span><br><span class="line">-l     指定最大的递归深度，0为无限。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.sanmi.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker for Mac与宿主机通信</title>
    <link href="http://blog.sanmi.site/2019/06/06/Docker-for-Mac%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.sanmi.site/2019/06/06/Docker-for-Mac与宿主机通信/</id>
    <published>2019-06-06T01:42:12.000Z</published>
    <updated>2019-06-06T02:20:02.579Z</updated>
    
    <content type="html"><![CDATA[<p>因为Docker for Mac的实现与Docker for Linux的实现有些不一样，所以在Mac上，当容器需要与宿主机进行通信的时候，发现直接访问宿主机的IP（ 172.17.0.1）是访问不通的。Mac的宿主机上，也没有docker0这个虚拟网卡。<br>当尝试访问宿主机的一个端口时，会提示Connection refused.</p><p>在container中应当使用一个特殊的DNS来访问宿主机<code>docker.for.mac.host.internal</code></p><p>参考链接：(<a href="https://imhanjm.com/2018/12/16/macos%20docker%20container%E8%BF%9E%E6%8E%A5%E5%AE%BF%E4%B8%BB%E6%9C%BA172.17.0.1%E7%9A%84%E5%8A%9E%E6%B3%95/" target="_blank" rel="noopener">Macos Docker container连接宿主机172.17.0.1的办法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://blog.sanmi.site/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>me</title>
    <link href="http://blog.sanmi.site/2019/05/10/me/"/>
    <id>http://blog.sanmi.site/2019/05/10/me/</id>
    <published>2019-05-10T05:18:24.000Z</published>
    <updated>2019-05-10T05:18:24.438Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
